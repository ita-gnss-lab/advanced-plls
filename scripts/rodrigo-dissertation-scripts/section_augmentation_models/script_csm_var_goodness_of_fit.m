% script_csm_var_goodness_of_fit.m
%
% Script to identify goodness of fit of the VAR model for scintillation 
% amplitude and phase time series generated by the Cornell scintillation
% model (CSM) using the ARFIT algorithm.
%
% Steps:
%   1) Monte Carlo assessment of optimal VAR orders per severity.
%   2) Extraction of residuals for the most frequent optimal orders.
%   3) Calculation of one-sided ACFs of those residuals.
%   4) Comparison of periodograms of synthetic signals vs. VAR power 
%      spectral densities.
%
% References:
% [1] Schneider, Tapio, and Arnold Neumaier. “Algorithm 808: ARfit—a Matlab 
% Package for the Estimation of Parameters and Eigenmodes of Multivariate
% Autoregressive Models.” ACM Trans. Math. Softw. 27, no. 1 
% (March 1, 2001): 58–65. https://doi.org/10.1145/382043.382316.
%
% Author: Rodrigo de Lima Florindo
% ORCID: https://orcid.org/0000-0003-0412-5583
% Email: rdlfresearch@gmail.com

clearvars; clc;
addpath(genpath(fullfile(pwd,'..','..','..','..','libs')));

%% Simulation parameters
simulation_time = 25;
sampling_interval = 0.01;
severities = {'Weak','Moderate','Strong'};
csm_params = struct( ...
    'Weak',    struct('S4', 0.2, 'tau0', 1, 'simulation_time', simulation_time, 'sampling_interval', sampling_interval),...
    'Moderate',struct('S4', 0.5, 'tau0', 0.6, 'simulation_time', simulation_time, 'sampling_interval', sampling_interval),...
    'Strong',  struct('S4', 0.9, 'tau0', 0.2, 'simulation_time', simulation_time, 'sampling_interval', sampling_interval)...
);

%% Monte Carlo optimal VAR model order assessment
mc_runs    = 1000;
min_order  = 1;
max_order  = 10;
optimal_orders_amp   = zeros(mc_runs,numel(severities));
optimal_orders_phase = zeros(mc_runs,numel(severities));

seed = 1;
for mc_idx = 1:mc_runs
    for i = 1:numel(severities)
        severity = severities{i};
        rng(seed);
        data      = get_csm_data(csm_params.(severity));
        amp_ts    = abs(data);
        phase_ts  = atan2(imag(data),real(data));

        [~, A_amp]   = arfit(amp_ts,   min_order, max_order);
        [~, A_phase] = arfit(phase_ts, min_order, max_order);

        optimal_orders_amp(mc_idx,i)   = size(A_amp,2)/size(A_amp,1);
        optimal_orders_phase(mc_idx,i) = size(A_phase,2)/size(A_phase,1);

        seed = seed + 1;
    end
end

orders       = min_order:max_order;
counts_amp   = zeros(numel(orders),numel(severities));
counts_phase = zeros(numel(orders),numel(severities));
for i = 1:numel(severities)
    counts_amp(:,i)   = histcounts(optimal_orders_amp(:,i),   [orders, orders(end)+1]);
    counts_phase(:,i) = histcounts(optimal_orders_phase(:,i), [orders, orders(end)+1]);
end

figure('Position',[100,100,900,400]);
subplot(1,2,1);
bar(orders,counts_amp,'grouped');
xlabel('VAR Model Order'); ylabel('Frequency');
title('Optimal VAR Orders (Amplitude)');
legend(severities,'Location','best'); grid on;
subplot(1,2,2);
bar(orders,counts_phase,'grouped');
xlabel('VAR Model Order'); ylabel('Frequency');
title('Optimal VAR Orders (Phase)');
legend(severities,'Location','best'); grid on;

%% Obtain residuals for most frequent orders
[~, highest_freq_idx_amp]   = max(counts_amp,[],1);
[~, highest_freq_idx_phase] = max(counts_phase,[],1);

residuals = struct('amplitude',[],'phase',[]);
seed = 1;
for i = 1:numel(severities)
    severity   = severities{i};
    rng(seed);
    data       = get_csm_data(csm_params.(severity));
    amp_ts     = abs(data);
    phase_ts   = atan2(imag(data),real(data));

    ord_amp    = orders(highest_freq_idx_amp(i));
    ord_phase  = orders(highest_freq_idx_phase(i));

    [w_amp,   A_amp]   = arfit(amp_ts,   ord_amp,   ord_amp);
    [w_phase, A_phase] = arfit(phase_ts, ord_phase, ord_phase);

    [~, res_amp]   = arres(w_amp,   A_amp,   amp_ts,   20);
    [~, res_phase] = arres(w_phase, A_phase, phase_ts, 20);

    residuals.amplitude.(severity) = [NaN(ord_amp,1);   res_amp];
    residuals.phase.(severity)     = [NaN(ord_phase,1); res_phase];

    seed = seed + 1;
end

%% Compute one-sided ACFs of residuals

% Amount of lags on the ACF
lags        = 20;
stem_width  = 1.5;
markers     = struct('Weak','o','Moderate','s','Strong','^');
acfs        = struct('amplitude',[],'phase',[]);

for i = 1:numel(severities)
    severity = severities{i};
    
    % Removing the NaNs of the amplitude and phase residuals
    amp_res  = residuals.amplitude.(severity);
    amp_res  = amp_res(~isnan(amp_res));
    phs_res  = residuals.phase.(severity);
    phs_res  = phs_res(~isnan(phs_res));

    acf_amp          = xcorr(amp_res, amp_res, lags, 'normalized');
    acf_phs          = xcorr(phs_res, phs_res, lags, 'normalized');
    acfs.amplitude.(severity) = acf_amp(lags+1:end);
    acfs.phase.(severity)     = acf_phs(lags+1:end);
end

time_lag = (0:lags) * sampling_interval;
figure('Position',[100,100,1200,400]);
subplot(1,2,1);
hold on;
for i = 1:numel(severities)
    severity = severities{i};
    stem(time_lag, acfs.amplitude.(severity), 'LineWidth', stem_width, ...
         'Marker', markers.(severity), 'DisplayName', severity);
end
hold off;
xlabel('Time Lag [s]'); ylabel('ACF Amplitude');
title('Amplitude Residuals ACF');
legend('Location','best'); grid on;

subplot(1,2,2);
hold on;
for i = 1:numel(severities)
    severity = severities{i};
    stem(time_lag, acfs.phase.(severity), 'LineWidth', stem_width, ...
         'Marker', markers.(severity), 'DisplayName', severity);
end
hold off;
xlabel('Time Lag [s]'); ylabel('ACF Phase');
title('Phase Residuals ACF');
legend('Location','best'); grid on;

%% [Future] Periodogram vs. VAR PSD comparison
% For each severity:
%   - compute periodogram of synthetic data
%   - derive PSD from VAR model coefficients
%   - plot both for comparison
