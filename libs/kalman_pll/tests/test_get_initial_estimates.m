classdef test_get_initial_estimates < matlab.unittest.TestCase
% test_get_initial_estimates
%
% Syntax:
%   results = runtests('test_get_initial_estimates')
%
% Description:
%   Unit tests for the get_initial_estimates function. Verifies that:
%   1) Random estimates are generated correctly when 
%      is_generate_random_initial_estimates is true.
%   2) Perfect estimates are used otherwise.
%   3) The function validates required fields and raises errors for 
%      missing or invalid config or kalman_pll_config inputs.
%
% Example:
%   % Run all tests in this suite:
%   results = runtests('test_get_initial_estimates');
%   disp(results);
%
% Author:
%   Rodrigo de Lima Florindo
%   ORCID: https://orcid.org/0000-0003-0412-5583
%   Email: rdlfresearch@gmail.com

    methods(TestClassSetup)
        function add_parent_path(test_case)
            % add_parent_path - Add the parent directory so that 
            % get_initial_estimates.m can be found.
            parent_dir = fileparts(fileparts(mfilename('fullpath')));
            addpath(parent_dir);
            test_case.addTeardown(@() rmpath(parent_dir));
        end
    end

    methods(Test)
        function test_valid_random_estimates(test_case)
            % test_valid_random_estimates
            % Ensures random initial estimates are generated when 
            % is_generate_random_initial_estimates is true.
            
            % Prepare config
            config = struct( ...
                'is_generate_random_initial_estimates', true, ...
                'initial_states_distributions_boundaries', {{[-pi, pi], [-5, 5], [-0.1, 0.1]}}, ...
                'real_doppler_profile', [1000, 0.94, 0.03], ...
                'training_scint_model', 'CSM' ...
            );
            
            % Prepare a simplified version of `kalman_pll_config`
            kalman_pll_config = struct(...
                'CSM', struct('var_states_amount', 2, 'var_model_order', 1), ...
                'TPPSM', struct(), ...
                'none', struct() ...
            );

            initial_estimates = get_initial_estimates(config, kalman_pll_config);

            test_case.verifyTrue(isstruct(initial_estimates), ...
                'Returned value should be a struct.');
            test_case.verifyTrue(isfield(initial_estimates, 'x_hat_init'), ...
                'Struct must have x_hat_init field.');
            test_case.verifyTrue(isfield(initial_estimates, 'P_hat_init'), ...
                'Struct must have P_hat_init field.');

            % Check sizes
            expected_los_length = numel(config.real_doppler_profile);
            var_length = kalman_pll_config.CSM.var_states_amount * ...
                         kalman_pll_config.CSM.var_model_order;
            total_length = expected_los_length + var_length;
            
            test_case.verifySize(initial_estimates.x_hat_init, [total_length, 1], ...
                'x_hat_init size mismatch for random estimates.');
            test_case.verifySize(initial_estimates.P_hat_init, [total_length, total_length], ...
                'P_hat_init size mismatch for random estimates.');
        end
        
        function test_valid_perfect_estimates(test_case)
            % test_valid_perfect_estimates
            % Ensures perfect initial estimates are used when 
            % is_generate_random_initial_estimates is false.
            
            config = struct( ...
                'is_generate_random_initial_estimates', false, ...
                'initial_states_distributions_boundaries', {{[-pi, pi], [-5, 5], [-0.1, 0.1]}}, ...
                'real_doppler_profile', [1000, 0.94, 0.03], ...
                'training_scint_model', 'CSM' ...
            );
            
            kalman_pll_config = struct(...
                'CSM', struct('var_states_amount', 2, 'var_model_order', 1), ...
                'TPPSM', struct(), ...
                'none', struct() ...
            );

            initial_estimates = get_initial_estimates(config, kalman_pll_config);
            
            test_case.verifyTrue(isstruct(initial_estimates), ...
                'Returned value should be a struct.');
            test_case.verifyTrue(isfield(initial_estimates, 'x_hat_init'), ...
                'Struct must have x_hat_init field.');
            test_case.verifyTrue(isfield(initial_estimates, 'P_hat_init'), ...
                'Struct must have P_hat_init field.');

            % Check sizes
            expected_los_length = numel(config.real_doppler_profile);
            var_length = kalman_pll_config.CSM.var_states_amount * ...
                         kalman_pll_config.CSM.var_model_order;
            total_length = expected_los_length + var_length;
            
            test_case.verifySize(initial_estimates.x_hat_init, [total_length, 1], ...
                'x_hat_init size mismatch for perfect estimates.');
            test_case.verifySize(initial_estimates.P_hat_init, [total_length, total_length], ...
                'P_hat_init size mismatch for perfect estimates.');
        end
        
        function test_missing_config_fields(test_case)
            % test_missing_config_fields
            % Verifies that errors are raised if required config fields are missing.
            
            invalid_config = struct( ...
                'is_generate_random_initial_estimates', true, ...
                'real_doppler_profile', [1000, 0.94, 0.03], ...
                'training_scint_model', 'CSM' ...
            );
            % Missing 'initial_states_distributions_boundaries'
            
            kalman_pll_config = struct('CSM', struct('var_states_amount', 2, 'var_model_order', 1));
            
            test_case.verifyError(@() get_initial_estimates(invalid_config, kalman_pll_config), ...
                'get_initial_estimates:MissingConfigField', ...
                'Expected an error due to missing config field.');
        end
        
        function test_boundaries_profile_mismatch(test_case)
            % test_boundaries_profile_mismatch
            % Ensures an error is thrown if the number of boundaries 
            % doesn't match real_doppler_profile length.
            
            config = struct( ...
                'is_generate_random_initial_estimates', true, ...
                'initial_states_distributions_boundaries', {{[-pi, pi], [-5, 5]}}, ... 
                'real_doppler_profile', [1000, 0.94, 0.03], ...
                'training_scint_model', 'CSM' ...
            );
            kalman_pll_config = struct('CSM', struct('var_states_amount', 2, 'var_model_order', 1));

            test_case.verifyError(@() get_initial_estimates(config, kalman_pll_config), ...
                'get_initial_estimates:BoundaryProfileMismatch', ...
                'Expected an error for mismatch in boundaries and profile lengths.');
        end
        
        function test_missing_kalman_substruct(test_case)
            % test_missing_kalman_substruct
            % Ensures an error is raised if kalman_pll_config lacks the scintillation model field.
            
            config = struct( ...
                'is_generate_random_initial_estimates', true, ...
                'initial_states_distributions_boundaries', {{[-pi, pi]}}, ...
                'real_doppler_profile', 1000, ...
                'training_scint_model', 'CSM' ...
            );
            % Missing 'CSM' sub-struct in kalman_pll_config
            kalman_pll_config = struct('TPPSM', struct(), 'none', struct());

            test_case.verifyError(@() get_initial_estimates(config, kalman_pll_config), ...
                'get_initial_estimates:MissingScintModelField', ...
                'Expected an error due to missing substruct for the chosen model.');
        end
        
        function test_missing_kalman_fields(test_case)
            % test_missing_kalman_fields
            % Checks if var_states_amount or var_model_order is absent, we get an error.
            
            config = struct( ...
                'is_generate_random_initial_estimates', false, ...
                'initial_states_distributions_boundaries', {{[-pi, pi]}}, ...
                'real_doppler_profile', 1000, ...
                'training_scint_model', 'CSM' ...
            );
            
            % Substruct missing var_model_order
            kalman_pll_config = struct('CSM', struct('var_states_amount', 2), 'TPPSM', struct(), 'none', struct());

            test_case.verifyError(@() get_initial_estimates(config, kalman_pll_config), ...
                'get_initial_estimates:MissingKalmanField', ...
                'Expected an error for missing var_model_order in kalman_pll_config.');
        end
    end
end
