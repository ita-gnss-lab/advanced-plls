classdef test_get_kalman_pll_estimates < matlab.unittest.TestCase
    % test_get_kalman_pll_estimates
    %
    % This test suite verifies the behavior of get_kalman_pll_estimates,
    % including validation of the adaptive configuration settings.
    %
    % Author:
    %   Rodrigo de Lima Florindo
    %   ORCID: https://orcid.org/0000-0003-0412-5583
    %   Email: rdlfresearch@gmail.com
    
    properties
        default_received_signal
        default_kalman_pll_config
        default_cache_dir
        default_initial_estimates
        default_kf_type
        default_training_model
        default_adaptive_config
        default_online_mdl_learning_cfg
    end
    
    methods(TestClassSetup)
        function add_parent_path(test_case)
            % Add the necessary directory paths
            parent_dir = fileparts(fileparts(mfilename('fullpath')));
            libs_dir = fileparts(parent_dir);
            get_received_signal_functions_dir = fullfile(libs_dir, 'get_received_signal_functions');
            tppsm_paths = genpath(fullfile(libs_dir, 'scintillation_models', 'refactored_tppsm'));
            csm_paths = genpath(fullfile(libs_dir, 'scintillation_models', 'cornell_scintillation_model'));
            arfit_path = fullfile(libs_dir, 'arfit');
            addpath(parent_dir);
            addpath(get_received_signal_functions_dir);
            addpath(tppsm_paths);
            addpath(csm_paths);
            addpath(arfit_path);

            test_case.addTeardown(@() rmpath(parent_dir, get_received_signal_functions_dir, ...
                tppsm_paths, csm_paths, arfit_path));
        end

        function setDefaultValues(testCase)
            % Define a default received signal (simulate 10 time steps).
            testCase.default_received_signal = ones(1000, 1) * exp(1j*0.1);  % Complex signal
            cache_dir = fullfile(fileparts(mfilename('fullpath')), 'cache_test_get_kalman_estimates');
            default_general_config = struct( ...
                'kf_type', 'standard', ...
                'discrete_wiener_model_config', { {1, 3, 0.01, [0,0,1], 1} }, ...
                'scintillation_training_data_config', struct('scintillation_model', 'CSM', 'S4', 0.8, 'tau0', 0.7, 'simulation_time', 300, 'sampling_interval', 0.01, 'is_unwrapping_used', false), ...
                'C_over_N0_array_dBHz', 35, ...
                'initial_states_distributions_boundaries', { {[-pi,pi], [-5,5], [-0.1,0.1]} }, ...
                'expected_doppler_profile', [0, 1000, 0.94], ...
                'augmentation_model_initializer', struct('id', 'arfit', 'model_params', struct('model_order', 3)), ...
                'is_use_cached_settings', false, ...
                'is_generate_random_initial_estimates', true ...
            );
            % Using dummy matrices
            [kcfg, initEst] = get_kalman_pll_config(default_general_config, cache_dir, false);
            testCase.default_kalman_pll_config = kcfg;
            testCase.default_initial_estimates = initEst;
            testCase.default_kf_type = 'standard';
            testCase.default_training_model = 'CSM';
            % Set a basic adaptive config using the new structure.
            testCase.default_adaptive_config = struct( ...
                'measurement_cov_adapt_algorithm', 'none', ...
                'states_cov_adapt_algorithm', 'none', ...
                'sampling_interval', 0.01, ...
                'hard_limited', struct('is_used', false, 'L1_C_over_N0_dBHz_threshold', 30));
            testCase.default_online_mdl_learning_cfg = struct('is_online', true, 'learning_method', 'sliding_window', 'window_size', 1500);
        end
    end

    methods(Test)
        function testValidInputs(testCase)
            % Valid configuration with both measurement and states adaptation set to 'none'
            [stateEst, errCovEst] = get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                testCase.default_adaptive_config, ...
                testCase.default_online_mdl_learning_cfg);
            
            % Check dimensions:
            testCase.verifyEqual(size(stateEst,1), size(testCase.default_received_signal,1));
            testCase.verifyEqual(size(stateEst,2), numel(testCase.default_initial_estimates.x_hat_init));
            testCase.verifyEqual(size(errCovEst,1), size(testCase.default_received_signal,1));
            testCase.verifyEqual(size(errCovEst,2), size(testCase.default_initial_estimates.P_hat_init,1));
            testCase.verifyEqual(size(errCovEst,3), size(testCase.default_initial_estimates.P_hat_init,2));
        end

        function testNonNumericReceivedSignal(testCase)
            % Passing a non-numeric received_signal should trigger an error.
            received_signal = 'not numeric';
            testCase.verifyError(@() get_kalman_pll_estimates(...
                received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                testCase.default_adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'MATLAB:get_kalman_pll_estimates:invalidType');
        end

        function testMissingInitialEstimatesFields(testCase)
            % Remove one field from initial_estimates to trigger an error.
            badEstimates = testCase.default_initial_estimates;
            badEstimates = rmfield(badEstimates, 'x_hat_init');
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                badEstimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                testCase.default_adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'get_kalman_pll_estimates:missing_field');
        end

        function testInvalidTrainingModel(testCase)
            % Use a training model that does not exist in kalman_pll_config.
            invalidModel = 'TPPSM';
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                invalidModel, ...
                testCase.default_adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'get_kalman_pll_estimates:missing_field');
        end

        function testInvalidTypeTrainingModel(testCase)
            % Provide a non-string for training_scint_model.
            invalidModel = 123;
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                invalidModel, ...
                testCase.default_adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'get_kalman_pll_estimates:invalid_type');
        end

        %% New tests for the adaptive configuration validation
        function testValidMeasurementAdaptiveSimplified(testCase)
            % Create a valid adaptive config for measurement covariance using the "simplified" algorithm.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.measurement_cov_adapt_algorithm = 'simplified';
            adaptive_config.measurement_cov_adapt_algorithm_params = struct( ...
                'L1_C_over_N0_dBHz', 35, ...
                'sampling_interval', 0.01);
            
            % Should work without error.
            [~, ~] = get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg);
        end

        function testValidMeasurementAdaptiveNWPR(testCase)
            % Create a valid adaptive config for measurement covariance using the "nwpr" algorithm.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.measurement_cov_adapt_algorithm = 'nwpr';
            adaptive_config.measurement_cov_adapt_algorithm_params = struct( ...
                'M_nwpr', 2, ...
                'N_nwpr', 20);
            
            [~, ~] = get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg);
        end

        function testMissingMeasurementAdaptiveParams(testCase)
            % When algorithm is "simplified", missing measurement_cov_adapt_algorithm_params should trigger an error.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.measurement_cov_adapt_algorithm = 'simplified';
            if isfield(adaptive_config, 'measurement_cov_adapt_algorithm_params')
                adaptive_config = rmfield(adaptive_config, 'measurement_cov_adapt_algorithm_params');
            end
            
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'validate_adaptive_config:missing_field');
        end

        function testInvalidMeasurementAdaptiveAlgorithm(testCase)
            % Provide an invalid measurement_cov_adapt_algorithm name.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.measurement_cov_adapt_algorithm = 'invalid_algo';
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'validate_adaptive_config:invalid_algorithm');
        end

        function testValidStatesAdaptiveMatching(testCase)
            % Create a valid adaptive config for state covariance using the "matching" algorithm.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.states_cov_adapt_algorithm = 'matching';
            adaptive_config.states_cov_adapt_algorithm_params = struct( ...
                'method', 'IAE', ... % or 'RAE'
                'window_size', 50);
            
            [~, ~] = get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg);
        end

        function testMissingStatesAdaptiveParams(testCase)
            % When states_cov_adapt_algorithm is "matching", missing its parameter struct should trigger an error.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.states_cov_adapt_algorithm = 'matching';
            if isfield(adaptive_config, 'states_cov_adapt_algorithm_params')
                adaptive_config = rmfield(adaptive_config, 'states_cov_adapt_algorithm_params');
            end
            
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'validate_adaptive_config:missing_field');
        end

        function testInvalidStatesAdaptiveMethod(testCase)
            % When using "matching", an invalid method (other than 'IAE' or 'RAE') should trigger an error.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.states_cov_adapt_algorithm = 'matching';
            adaptive_config.states_cov_adapt_algorithm_params = struct( ...
                'method', 'invalid_method', ...
                'window_size', 50);
            
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'validate_adaptive_config:invalid_method');
        end

        function testInvalidHardLimitedType(testCase)
            % Provide a non-logical value for hard_limited.is_used to trigger an error.
            adaptive_config = testCase.default_adaptive_config;
            adaptive_config.hard_limited.is_used = 'not_boolean';
            testCase.verifyError(@() get_kalman_pll_estimates(...
                testCase.default_received_signal, ...
                testCase.default_kalman_pll_config, ...
                testCase.default_initial_estimates, ...
                testCase.default_kf_type, ...
                testCase.default_training_model, ...
                adaptive_config, ...
                testCase.default_online_mdl_learning_cfg), ...
                'MATLAB:get_kalman_pll_estimates:invalidType');
        end
    end
end