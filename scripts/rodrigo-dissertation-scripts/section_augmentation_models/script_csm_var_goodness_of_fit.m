% get_csm_optimum_var_order.m
%
% This script was used to identify the most common vector autoregressive 
% (VAR) model orders of scintillation amplitude and phase time series 
% generated by the Cornell scintillation model (CSM), based on the ARFIT
% algorithm [1].
%
% References:
% [1] Schneider, Tapio, and Arnold Neumaier. “Algorithm 808: ARfit—a Matlab 
% Package for the Estimation of Parameters and Eigenmodes of Multivariate
% Autoregressive Models.” ACM Trans. Math. Softw. 27, no. 1 
% (March 1, 2001): 58–65. https://doi.org/10.1145/382043.382316.
%
% Author: Rodrigo de Lima Florindo
% ORCID: https://orcid.org/0000-0003-0412-5583
% Email: rdlfresearch@gmail.com

clearvars; clc;

addpath(genpath(fullfile(pwd, '..', '..', '..', '..',  'libs')));

%% Simulation Parameters
sim_time = 25;
t_samp = 0.01;
csm_params.Weak = struct('S4', 0.2, ...
    'tau0', 1, ...
    'simulation_time', sim_time, ...
    'sampling_interval', t_samp);
csm_params.Moderate = struct('S4', 0.5, ...
    'tau0', 0.6, ...
    'simulation_time', sim_time, ...
    'sampling_interval', t_samp);
csm_params.Strong = struct('S4', 0.9, ...
    'tau0', 0.2, ...
    'simulation_time', sim_time, ...
    'sampling_interval', t_samp);

%% Monte Carlo optimum model order assessment

% Amount of Monte Carlo runs
mc_runs_amount = 1000;
% Maximum VAR model order
maximum_order = 10;
% Minimum VAR model order
minimum_order = 1;
% Preallocate a string array with the severities names
severities_string_array = ["Weak", "Moderate", "Strong"];
% Preallocate a array with the obtained optimal model orders for each
% scintillation severity.
optimal_orders_results_amp = zeros(mc_runs_amount, length(severities_string_array));
optimal_orders_results_phase = zeros(mc_runs_amount, length(severities_string_array));

seed = 1;
for mc_run = 1:mc_runs_amount
    for severity = severities_string_array
        % Modify the generation seed
        rng(seed);

        % Find the actual severity index
        severity_idx = find(severities_string_array == severity);

        % Obtain the synthetic scintillation time series generated using
        % the CSM.
        scint_time_series = get_csm_data(csm_params.(severity));
        
        amplitude_time_series = abs(scint_time_series);
        phase_time_series = atan2(imag(scint_time_series),real(scint_time_series));
        % Fit the VAR model in the generated scintillation time series 
        % amplitude and wrapped phase (within the bounds [-pi,pi] obtained 
        % using an atan2 function).
        % NOTE: The estimated optimal model order can be obtained from the
        % ratio between the amount of columns and rows of the coefficient 
        % matrix estimated by the ARFIT algorithm. That's because
        % its amount of rows corresponds to the amount of states and the
        % amount of columns represents the amount of states multiplied by
        % the estimated model order.
        % NOTE: In this specific case, the amount of states is 1, given
        % that CSM only simulates single-frequency scintillation
        % realizations.
        [~, A_amp, ~, ~, ~, ~] = arfit(amplitude_time_series, minimum_order, maximum_order);
        est_opt_mdl_order_amp = size(A_amp,2) / size(A_amp,1);
        [~, A_phase, ~, ~, ~, ~] = arfit(phase_time_series, minimum_order, maximum_order);
        est_opt_mdl_order_phase = size(A_phase,2) / size(A_phase,1);
        % Store the optimal order obtained for this Monte Carlo run
        optimal_orders_results_amp(mc_run, severity_idx) = est_opt_mdl_order_amp;
        optimal_orders_results_phase(mc_run, severity_idx) = est_opt_mdl_order_phase;
        seed = seed + 1;
    end
end

orders = minimum_order:maximum_order;
orders_amount = numel(orders);
severities_amount    = numel(severities_string_array);

% Preallocate count matrices
counts_amp   = zeros(orders_amount, severities_amount);
counts_phase = zeros(orders_amount, severities_amount);

% Compute histograms
for i = 1:severities_amount
    counts_amp(:,i)   = histcounts(optimal_orders_results_amp(:,i),   [orders, max(orders)+1]);
    counts_phase(:,i) = histcounts(optimal_orders_results_phase(:,i), [orders, max(orders)+1]);
end

% ---- Plot for Amplitude ----
figure('Position', [100, 100, 900, 400]);
subplot(1,2,1);
bar(orders, counts_amp, 'grouped');
xlabel('VAR Model Order');
ylabel('Frequency');
title('Occurrence of Optimal VAR Orders (Amplitude)');
legend(severities_string_array, 'Location','best');
grid on;

% ---- Plot for Phase ----
subplot(1,2,2);
bar(orders, counts_phase, 'grouped');
xlabel('VAR Model Order');
ylabel('Frequency');
title('Occurrence of Optimal VAR Orders (Phase)');
legend(severities_string_array, 'Location','best');
grid on;

%% Obtain the residuals of the frequent optimal orders for each severity scenario

% Obtain the orders with highest frequency
[~,frequent_opt_orders_amp] = max(counts_amp, [], 1);
[~,frequent_opt_orders_phase] = max(counts_phase, [], 1);

residuals = struct('amplitude', struct('Weak', [], 'Moderate', [], 'Strong', []), ...
                   'phase',     struct('Weak', [], 'Moderate', [], 'Strong', []));
seed = 1;
for severity = severities_string_array
    % Modify the generation seed
    rng(seed);

    % Find the actual severity index
    severity_idx = find(severities_string_array == severity);

    % Obtain the synthetic scintillation time series generated using
    % the CSM.
    scint_time_series = get_csm_data(csm_params.(severity));
    
    amplitude_time_series = abs(scint_time_series);
    phase_time_series = atan2(imag(scint_time_series),real(scint_time_series));


    [w_frequent_amp, A_frequent_amp, C_frequent_amp, ~, ~, ~] = arfit(amplitude_time_series, frequent_opt_orders_amp(severity_idx), frequent_opt_orders_amp(severity_idx));
    [w_frequent_phase, A_frequent_phase, C_frequent_phase, ~, ~, ~] = arfit(phase_time_series, frequent_opt_orders_phase(severity_idx), frequent_opt_orders_phase(severity_idx));

    % Number of correlation lags used by arres for computing some metrics
    k = 20;
    [~, residuals.amplitude.(severity)] = arres(w_frequent_amp, A_frequent_amp, amplitude_time_series, k);
    [~, residuals.phase.(severity)] = arres(w_frequent_phase, A_frequent_phase, phase_time_series, k);

    residuals.amplitude.(severity) = [NaN(frequent_opt_orders_amp(severity_idx),1); residuals.amplitude.(severity)];
    residuals.phase.(severity) = [NaN(frequent_opt_orders_phase(severity_idx),1); residuals.phase.(severity)];
    seed = seed + 1;
end

time = t_samp:t_samp:sim_time;

% Plot the amplitude and phase residuals
figure('Position', [100, 100, 1200, 400]);

subplot(1,2,1);
hold on;
for severity = severities_string_array
    plot(time, residuals.amplitude.(severity), 'LineWidth', 2, 'LineStyle',':');
end
hold off;
xlabel('Time [sec]');
ylabel('Amplitude Residuals');
title('Optimal VAR model residuals (Phase)');
legend(severities_string_array, 'Location','best');

subplot(1,2,2);
hold on;
for severity = severities_string_array
    plot(time, residuals.phase.(severity), 'LineWidth', 2, 'LineStyle',':');
end
hold off;
xlabel('Time [sec]');
ylabel('Phase Residuals');
title('Optimal VAR model residuals (Phase)');
legend(severities_string_array, 'Location','best');

%% Obtain the autocorrelation (ACF) function of the residuals

severities   = {'Weak','Moderate','Strong'};
markerMap    = struct('Weak','o',...    % circle for Weak
                      'Moderate','s',... % square for Moderate
                      'Strong','^');     % triangle for Strong
stemLineWidth = 1.5;         % stem line width
lags = 20;

% Pre-allocate result structure
acfs = struct('amplitude',[],'phase',[]);
for i = 1:numel(severities)
    s = severities{i};
    acfs.amplitude.(s) = nan(lags+1,1);
    acfs.phase    .(s) = nan(lags+1,1);
end

% Compute one-sided normalized ACF for each severity and residual type
for i = 1:numel(severities)
    s = severities{i};
    
    % extract and clean NaNs
    amp_res = residuals.amplitude.(s);
    amp_res = amp_res(~isnan(amp_res));
    phs_res = residuals.phase.(s);
    phs_res = phs_res(~isnan(phs_res));
    
    % compute normalized autocorrelation and take positive lags
    acf_amp = xcorr(amp_res, amp_res, lags, 'normalized');
    acf_phs = xcorr(phs_res, phs_res, lags, 'normalized');
    
    acfs.amplitude.(s) = acf_amp(lags+1:end);
    acfs.phase    .(s) = acf_phs(lags+1:end);
end

% Time-lag axis
time_lag = (0:lags) * t_samp;

% Plot amplitude and phase ACFs
figure('Position',[100,100,1200,400]);

subplot(1,2,1);
hold on;
for i = 1:numel(severities)
    s = severities{i};
    stem(time_lag, acfs.amplitude.(s), ...
         'LineWidth', stemLineWidth, ...
         'Marker',    markerMap.(s), ...
         'DisplayName', s);
end
hold off;
xlabel('Time Lag [s]');
ylabel('ACF Amplitude');
title('Amplitude Residuals ACF');
legend('Location','best');
grid on;

subplot(1,2,2);
hold on;
for i = 1:numel(severities)
    s = severities{i};
    stem(time_lag, acfs.phase.(s), ...
         'LineWidth', stemLineWidth, ...
         'Marker',    markerMap.(s), ...
         'DisplayName', s);
end
hold off;
xlabel('Time Lag [s]');
ylabel('ACF Phase');
title('Phase Residuals ACF');
legend('Location','best');
grid on;