classdef test_get_mfpsm_data < matlab.unittest.TestCase
% test_get_mfpsm_data
% Unit tests for the `get_mfpsm_data` function, which simulates 
% Multi-frequency Phase Screen Model (MFPSM) time series based on 
% specified scintillation parameters.
%
% This test suite validates the correctness and robustness of the `get_mfpsm_data` 
% function by testing its behavior under various scenarios, including:
%
% **Functional Tests**:
%   - Ensure valid inputs produce a non-empty, complex output.
%
% **Validation Tests**:
%   - Dynamically validate error handling for invalid inputs, including:
%       1. Negative or out-of-range values for `S4`.
%       2. Non-numeric, non-scalar, or invalid `tau0`, `simulation_time`, 
%          and `sampling_interval`.
%
% Example:
%   To run the test suite:
%       results = runtests('test_get_csm_data');
%       disp(results);
%
% Author:
%   Rodrigo de Lima Florindo
%   ORCID: https://orcid.org/0000-0003-0412-5583
%   Email: rdlfresearch@gmail.com

properties
    % Valid Test Parameters
    S4 = 0.8;                   % Valid S4 index
    tau0 = 0.7;                 % Valid decorrelation time
    simulation_time = 300;      % Valid total simulation time
    sampling_interval = 0.01;   % Valid sampling time
    invalid_inputs              % Dynamically generated invalid input cases
end

properties (TestParameter)
    % Parameterized input names for dynamic testing
    input_name = struct(...
        'S4', 'S4', ...
        'tau0', 'tau0', ...
        'simulation_time', 'simulation_time', ...
        'sampling_interval', 'sampling_interval' ...
    );
end

methods (TestClassSetup)
    function classSetup(testCase)
        % Add parent directory and dependencies to the path
        paths = {fullfile(pwd, '..'), ...
                 fullfile(pwd, '..', '..', 'scintillation_models', 'cornell_scintillation_model')};
        for pathToAdd = paths
            if ~contains(path, pathToAdd{1})
                addpath(pathToAdd{1});
                testCase.addTeardown(@() rmpath(pathToAdd{1}));
            end
        end

        % Define invalid input cases dynamically
        testCase.invalid_inputs = struct(...
            'S4', { ...
                {'invalid', 'MATLAB:get_mfpsm_data:invalidType'; ...
                 true, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 {0.8}, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 [0.8, 0.9], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 zeros(2, 2), 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 -0.1, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 1.1, 'MATLAB:get_mfpsm_data:notLessEqual'; ...
                 Inf, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 -Inf, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 NaN, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 [], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 0.8 + 1j, 'MATLAB:get_mfpsm_data:expectedReal' ...
                }}, ...
            'tau0', { ...
                {'invalid', 'MATLAB:get_mfpsm_data:invalidType'; ...
                 true, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 {0.7}, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 [0.7, 0.8], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 zeros(2, 2), 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 -0.5, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 Inf, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 -Inf, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 NaN, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 [], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 0.7 + 1j, 'MATLAB:get_mfpsm_data:expectedReal' ...
                }}, ...
            'simulation_time', { ...
                {'invalid', 'MATLAB:get_mfpsm_data:invalidType'; ...
                 true, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 {300}, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 [300, 400], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 zeros(3, 3), 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 -300, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 0, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 Inf, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 -Inf, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 NaN, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 [], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 300 + 1j, 'MATLAB:get_mfpsm_data:expectedReal' ...
                }}, ...
            'sampling_interval', { ...
                {'invalid', 'MATLAB:get_mfpsm_data:invalidType'; ...
                 true, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 {0.01}, 'MATLAB:get_mfpsm_data:invalidType'; ...
                 [0.01, 0.02], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 zeros(3, 3), 'MATLAB:get_mfpsm_data:expectedScalar'; ...invalid_inputs
                 -0.01, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 0, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 Inf, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 -Inf, 'MATLAB:get_mfpsm_data:expectedPositive'; ...
                 NaN, 'MATLAB:get_mfpsm_data:expectedFinite'; ...
                 [], 'MATLAB:get_mfpsm_data:expectedScalar'; ...
                 0.01 + 1j, 'MATLAB:get_mfpsm_data:expectedReal' ...
                }} ...
        );
    end
end

methods (Test)

    %% Validation Tests
    function test_invalid_inputs(testCase, input_name)
        % Dynamically validate invalid inputs
        testCase.run_validation_tests(input_name, testCase.invalid_inputs.(input_name));
    end
end

methods
    function run_validation_tests(testCase, input_name, invalidCases)
        % Iterate through invalid cases and verify errors
        for invalidCase = invalidCases.'
            invalidInput = invalidCase{1}; % Extract invalid value
            expectedError = invalidCase{2}; % Extract expected error ID

            % Generate function inputs
            inputs = testCase.generate_inputs(input_name, invalidInput);
            invalidInputStr = testCase.safe_input_strings(invalidInput);

            % Validate the function throws the expected error
            testCase.verifyError(@() get_mfpsm_data(inputs{:}), expectedError, ...
                sprintf('Validation failed for %s with input: %s', input_name, invalidInputStr));
        end
    end

    function inputs = generate_inputs(testCase, fieldName, value)
        % Generate inputs for get_mfpsm_data, replacing specified field
        inputs = {testCase.S4, testCase.tau0, testCase.simulation_time, testCase.sampling_interval};
        fieldNames = {'S4', 'tau0', 'simulation_time', 'sampling_interval'};
        inputs(strcmp(fieldNames, fieldName)) = {value};
    end

    function str = safe_input_strings(~, input)
        % Safely convert input to string for error messages
        if ischar(input) || isstring(input)
            str = char(input);
        elseif isnumeric(input) || islogical(input)
            str = mat2str(input);
        else
            str = '<unconvertible input>';
        end
    end
end

end
