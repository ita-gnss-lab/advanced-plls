% script_csm_var_goodness_of_fit.m
%
% Script to identify the goodness of fit of the VAR model for scintillation 
% amplitude and phase time series generated by the Cornell scintillation
% model (CSM) using the ARFIT algorithm.
%
% Steps:
%   1) Monte Carlo assessment of optimal VAR orders per severity.
%   2) Extraction of residuals for the most frequent optimal orders.
%   3) Calculation of one-sided ACFs of those residuals.
%   4) Comparison of periodograms of the synthetic signals generated using 
%      the CSM vs. estimated VAR model's power spectral densities.
%
% References:
% [1] Schneider, Tapio, and Arnold Neumaier. “Algorithm 808: ARfit—a Matlab 
% Package for the Estimation of Parameters and Eigenmodes of Multivariate
% Autoregressive Models.” ACM Trans. Math. Softw. 27, no. 1 
% (March 1, 2001): 58–65. https://doi.org/10.1145/382043.382316.
%
% Author: Rodrigo de Lima Florindo
% ORCID: https://orcid.org/0000-0003-0412-5583
% Email: rdlfresearch@gmail.com

clearvars; clc;
addpath(genpath(fullfile(pwd,'..','..','..', 'libs')));

%% Simulation parameters
simulation_time = 300;
sampling_interval = 0.01;
severities = {'Weak','Moderate','Strong'};
csm_params = struct( ...
    'Weak',    struct('S4', 0.2, 'tau0', 1, 'simulation_time', simulation_time, 'sampling_interval', sampling_interval),...
    'Moderate',struct('S4', 0.5, 'tau0', 0.6, 'simulation_time', simulation_time, 'sampling_interval', sampling_interval),...
    'Strong',  struct('S4', 0.9, 'tau0', 0.2, 'simulation_time', simulation_time, 'sampling_interval', sampling_interval)...
);

%% Monte Carlo optimal VAR model order assessment
mc_runs    = 1000;
min_order  = 1;
max_order  = 10;
optimal_orders_amp   = zeros(mc_runs,numel(severities));
optimal_orders_phase = zeros(mc_runs,numel(severities));

for mc_idx = 1:mc_runs
    for i = 1:numel(severities)
        severity = severities{i};
        rng(seed);
        data      = get_csm_data(csm_params.(severity));
        amp_ts    = abs(data);
        phase_ts  = atan2(imag(data),real(data));

        [~, A_amp]   = arfit(amp_ts,   min_order, max_order);
        [~, A_phase] = arfit(phase_ts, min_order, max_order);

        optimal_orders_amp(mc_idx,i)   = size(A_amp,2)/size(A_amp,1);
        optimal_orders_phase(mc_idx,i) = size(A_phase,2)/size(A_phase,1);
    end
end

orders       = min_order:max_order;
counts_amp   = zeros(numel(orders),numel(severities));
counts_phase = zeros(numel(orders),numel(severities));
for i = 1:numel(severities)
    counts_amp(:,i)   = histcounts(optimal_orders_amp(:,i),   [orders, orders(end)+1]);
    counts_phase(:,i) = histcounts(optimal_orders_phase(:,i), [orders, orders(end)+1]);
end

figure('Position',[100,100,900,400]);
subplot(1,2,1);
bar(orders,counts_amp,'grouped');
xlabel('VAR Model Order'); ylabel('Frequency');
title('Optimal VAR Orders (Amplitude)');
legend(severities,'Location','best'); grid on;
subplot(1,2,2);
bar(orders,counts_phase,'grouped');
xlabel('VAR Model Order'); ylabel('Frequency');
title('Optimal VAR Orders (Phase)');
legend(severities,'Location','best'); grid on;

%% Obtain residuals for most frequent orders
[~, highest_freq_idx_amp]   = max(counts_amp,[],1);
[~, highest_freq_idx_phase] = max(counts_phase,[],1);

residuals = struct('amplitude',[],'phase',[]);
for i = 1:numel(severities)
    severity   = severities{i};
    rng(i);
    data       = get_csm_data(csm_params.(severity));
    amp_ts     = abs(data);
    phase_ts   = atan2(imag(data),real(data));

    ord_amp    = orders(highest_freq_idx_amp(i));
    ord_phase  = orders(highest_freq_idx_phase(i));

    [w_amp,   A_amp]   = arfit(amp_ts,   ord_amp,   ord_amp);
    [w_phase, A_phase] = arfit(phase_ts, ord_phase, ord_phase);

    [~, res_amp]   = arres(w_amp,   A_amp,   amp_ts,   20);
    [~, res_phase] = arres(w_phase, A_phase, phase_ts, 20);

    residuals.amplitude.(severity) = [NaN(ord_amp,1);   res_amp];
    residuals.phase.(severity)     = [NaN(ord_phase,1); res_phase];
end

%% Compute one-sided ACFs of residuals

% Amount of lags on the ACF
lags        = 20;
stem_width  = 1.5;
markers     = struct('Weak','o','Moderate','s','Strong','^');
acfs        = struct('amplitude',[],'phase',[]);

for i = 1:numel(severities)
    severity = severities{i};
    
    % Removing the NaNs of the amplitude and phase residuals
    amp_res  = residuals.amplitude.(severity);
    amp_res  = amp_res(~isnan(amp_res));
    phs_res  = residuals.phase.(severity);
    phs_res  = phs_res(~isnan(phs_res));

    acf_amp          = xcorr(amp_res, amp_res, lags, 'normalized');
    acf_phs          = xcorr(phs_res, phs_res, lags, 'normalized');
    acfs.amplitude.(severity) = acf_amp(lags+1:end);
    acfs.phase.(severity)     = acf_phs(lags+1:end);
end

time_lag = (0:lags) * sampling_interval;
figure('Position',[100,100,1200,400]);
subplot(1,2,1);
hold on;
for i = 1:numel(severities)
    severity = severities{i};
    stem(time_lag, acfs.amplitude.(severity), 'LineWidth', stem_width, ...
         'Marker', markers.(severity), 'DisplayName', severity);
end
hold off;
xlabel('Time Lag [s]'); ylabel('ACF Amplitude');
title('Amplitude Residuals ACF');
legend('Location','best'); grid on;

subplot(1,2,2);
hold on;
for i = 1:numel(severities)
    severity = severities{i};
    stem(time_lag, acfs.phase.(severity), 'LineWidth', stem_width, ...
         'Marker', markers.(severity), 'DisplayName', severity);
end
hold off;
xlabel('Time Lag [s]'); ylabel('ACF Phase');
title('Phase Residuals ACF');
legend('Location','best'); grid on;

%% Periodogram vs. VAR PSD comparison

% Number of points on the frequency domain
nfft = 2^16;
% Sampling frequency in Hz
fs   = 1/sampling_interval;

% Struct for pre-allocating the frequency support, the periodograms and 
% the VAR model's.
psd_comparison = struct( ...
  'freq',     [], ...
  'amplitude', struct('periodogram',[],'var_psd',[]), ...
  'phase',     struct('periodogram',[],'var_psd',[]) ...
);

for i = 1:numel(severities)
    sev = severities{i};
    rng(i);

    %---- 1) Generate & center signals ------------------------------------
    x        = get_csm_data(csm_params.(sev));
    amp_ts   = abs(x);
    phase_ts = atan2(imag(x), real(x));

    % center for correlation
    amp_ctr = amp_ts   - mean(amp_ts);
    phs_ctr = phase_ts - mean(phase_ts);

    %---- 2) Get the autocovariance sequence ------------------------------
    % returns c_full with lags = -(N-1):(N-1)
    [c_amp_full, lags] = xcorr(amp_ctr,   'biased');
    [c_phs_full, ~   ] = xcorr(phs_ctr,   'biased');

    %---- 3) FFT of autocovariance sequence → two-sided PSD --
    % Amount of samples of the cross-correlation function (2 * N - 1)
    Ncorr      = numel(c_amp_full);
    % Amount of samples remaing to complete the fft size.
    pad_amount = nfft - Ncorr;
    C_amp_pad  = [c_amp_full; zeros(pad_amount,1)];
    C_phs_pad  = [c_phs_full; zeros(pad_amount,1)];

    % Get the fft of the padded autocovariance sequences
    S_amp_full = fft(C_amp_pad);
    S_phs_full = fft(C_phs_pad);

    % one-sided indices: {1 ... nfft/2+1}
    half = 1:(nfft/2+1);

    
    % Remove the remaining imaginary parts of the estimated periodogram.
    % NOTE: Here we multiply the periodogram with the sampling interval to
    % normalize it such that we have its unit in [dB/Hz]
    periodogram_amp = real(abs(S_amp_full(half))) * sampling_interval;
    periodogram_phs = real(abs(S_phs_full(half))) * sampling_interval;

    % store freq once
    if isempty(psd_comparison.freq)
        % Parse the frequency support in Hz
        psd_comparison.freq = (half-1)*(fs/nfft);
    end

    %---- 4) Fit AR(p) & compute VAR-PSD (unchanged) ----------------------
    p_amp = orders(highest_freq_idx_amp(i));
    p_phs = orders(highest_freq_idx_phase(i));
    [~, A_amp, C_amp] = arfit(amp_ts,   p_amp, p_amp);
    [~, A_phs, C_phs] = arfit(phase_ts, p_phs, p_phs);

    a_amp = [1, -reshape(A_amp,1,[])];
    a_phs = [1, -reshape(A_phs,1,[])];
    
    % evaluate H at each frequency bin
    z = exp(-1j*2*pi*psd_comparison.freq*sampling_interval);
    H_amp  = zeros(size(z));
    H_phs  = zeros(size(z));

    for k = 0:p_amp
      H_amp = H_amp + a_amp(k+1) * z.^(-k);
    end
    H_amp = 1 ./ H_amp;

    for k = 0:p_phs
      H_phs = H_phs + a_phs(k+1) * z.^(-k);
    end
    H_phs = 1 ./ H_phs;

    S_var_amp = (C_amp/fs)  * abs(H_amp).^2;
    S_var_phs = (C_phs/fs)  * abs(H_phs).^2;

    %---- 5) Stash results ------------------------------------------------
    psd_comparison.amplitude.(sev).periodogram = periodogram_amp;
    psd_comparison.amplitude.(sev).var_psd            = S_var_amp;
    psd_comparison.phase.(sev).periodogram     = periodogram_phs;
    psd_comparison.phase.(sev).var_psd                = S_var_phs;
end

%---- Plot ----------------------------------------------------------------
cmap_p = winter(numel(severities));  % periodogram lines
cmap_v = autumn(numel(severities));  % VAR-PSD     lines

figure('Position',[100,100,1200,400]);
F = psd_comparison.freq;

% Amplitude
subplot(1,2,1); hold on;
h_amp = gobjects(2*numel(severities),1);
for k=1:numel(severities)
  sev = severities{k};
  idx = 2*(k-1)+1;
  h_amp(idx)   = plot(F, 10*log10(psd_comparison.amplitude.(sev).periodogram), '--', ...
                      'Color',cmap_p(k,:), 'LineWidth',1, 'DisplayName',[sev ' – Corr. PSD']);
  h_amp(idx+1) = plot(F, 10*log10(psd_comparison.amplitude.(sev).var_psd),           '-', ...
                      'Color',cmap_v(k,:), 'LineWidth',2, 'DisplayName',[sev ' – VAR PSD']);
end
hold off;
set(gca,'XScale','log','XLim',[1e-4*fs,0.4*fs]);
xlabel('Frequency [Hz]'); ylabel('Power [dB]');
title('Amplitude: Corr-based PSD vs. VAR PSD');
grid on; legend(h_amp,'Location','best');

% Phase
subplot(1,2,2); hold on;
h_phs = gobjects(2*numel(severities),1);
for k=1:numel(severities)
  sev = severities{k};
  idx = 2*(k-1)+1;
  h_phs(idx)   = plot(F, 10*log10(psd_comparison.phase.(sev).periodogram), '--', ...
                      'Color',cmap_p(k,:), 'LineWidth',1, 'DisplayName',[sev ' – Corr. PSD']);
  h_phs(idx+1) = plot(F, 10*log10(psd_comparison.phase.(sev).var_psd),           '-', ...
                      'Color',cmap_v(k,:), 'LineWidth',2, 'DisplayName',[sev ' – VAR PSD']);
end
hold off;
set(gca,'XScale','log','XLim',[1e-4*fs,0.4*fs]);
xlabel('Frequency [Hz]'); ylabel('Power [dB]');
title('Phase: Corr-based PSD vs. VAR PSD');
grid on; legend(h_phs,'Location','best');
